---
title: 'Supplementary material: Risk factors for mortality among hospitalized patients with COVID-19'
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: true
    number_sections: TRUE
    code_folding: show
---

# Overview
This document contains supplementary material for the paper titled ["Risk factors for mortality among hospitalized patients with COVID-19"](https://www.medrxiv.org/content/10.1101/2020.09.22.20196204v1). It contains all tables and figures presented in the paper, as well as supplemental results. All code for the statistical analyses can be viewed in this document and are available at our [GitHub repository](https://github.com/phcanalytics/covid19-prognostic-model), but note that we are unfortunately not allowed to publicly share the data.

The figures and tables in the main text are contained in the following sections:

* **Table 1**: [Section 3.5](#table1)
* **Figure 1**: [Section 6.5.1](#summary-or-full)
* **Figure 2**: [Section 6.4](#variable-importance)
* **Figure 3**: [Section 6.7.3](#pred-probs-age-time)
* **Figure 4**: [Section 8.4](#calibration-test) (first plot) 
* **Table 2**:  [Section 8.3](#evaluation-metrics-test)

Analyses were run using the following `R` packages and settings.

```{r, include = FALSE}
# So that it can be viewed on GitHub pages, render with:
# rmarkdown::render(input = "supplement.Rmd", output_dir = "docs")
# To clear cache, delete the `supplement_cache` directory
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r, warning = FALSE, message = FALSE}
# R packages
library("corrr") 
library("dplyr") 
library("DT") 
library("ggplot2") 
library("glmnet") 
library("oem") 
library("gridExtra") 
library("knitr") 
library("kableExtra") 
library("magrittr") 
library("mice") 
library("purrr") 
library("rcompanion") 
library("rms") 
library("splines") 
library("tableone") 
library("tibble") 
library("tidyr") 

# Namespace clash
select <- dplyr::select

# Settings
set.seed(123)
theme_set(theme_bw())
n_imputations <- 5    # Number of multiple imputations with MICE
n_boot_val <- 50      # Number of bootstraps with rms validation and calibration
n_boot_probs <- 100   # Number of bootstraps for computing predicted probability CIs
n_rep <- 20           # Number of repeats with group lasso (for each of the n_imputations)
```

# Data
We begin by loading the "training" dataset and restrict to (i) patients age 18 and older and (ii) with an index date more than 2 weeks prior to the data release. We will also do a small amount of data "cleaning" and create nice labels for possible predictor variables.

## Load
```{r, message = TRUE}
filter_ie <- function(data){
  data1 <- data %>%
    filter(age >= 18) 
  data2 <- data1 %>%
    filter(as.Date("2020-06-05") - index_date > 14)
  n_dropped <- nrow(data1) - nrow(data2)
  percent_dropped <- formatC(100 * n_dropped/nrow(data1), 
                             format = "f", digits = 2)
  message(n_dropped, " (", percent_dropped, "%)",
          " patients were dropped due to the 2-week cutoff.")
  return(data2)
}

train_data <- readRDS("train_data.rds")  %>%
  filter_ie()
```

## Clean 
```{r}
# Function to add race/ethnicity variable to dataset (done after separately 
# imputing missing race + ethnicity information)
add_race_ethnicity <- function(data){
  data %>% mutate(
    race_ethnicity = case_when(
      race == "Caucasian" & ethnicity != "Hispanic" ~ "Non-Hispanic white",
      race == "African American" & ethnicity != "Hispanic" ~ "Non-Hispanic black",
      race == "Asian" & ethnicity != "Hispanic" ~ "Asian",
      is.na(race) | is.na(ethnicity) ~ NA_character_,
      TRUE ~ "Hispanic"
    ),
    race_ethnicity = relevel(factor(race_ethnicity), ref = "Non-Hispanic white")
  )
}
```

```{r}
clean_data <- function(data){
  # Recoding
data <- data %>% 
  mutate(
    ## "died" should be an integer
    died = as.integer(died),
    
    ## Convert unknown or other/unknown to missing
    race = ifelse(race == "Other/Unknown", NA, race),
    ethnicity = ifelse(ethnicity == "Unknown", NA, ethnicity),
    sex = ifelse(sex == "Unknown", NA, sex),
    
    ## Oxygen saturation should have plausible values
    spo2 = ifelse(spo2 == 0, NA_real_, spo2),
    spo2 = ifelse(spo2 > 100, 100, spo2),
    
    # # Division
    ## Set "Other" region to missing since all 9 geographic regions are in the data
    division = ifelse(division == "Other", NA, division),
    
    ## Move small categories to other
    division = ifelse(division %in% c("East South Central", "Mountain"),
                      "Other", 
                      division)
  ) %>%
  
  ## Better names for some variables
  rename(diabunc = diab, cci = score) %>%
  
  ## CCI should be an integer
  mutate(cci = as.integer(cci)) %>%
  
  ## Convert comorbidities to character
  mutate_at(
    c("ami", "chf", "pvd", "cevd", "dementia", "cpd", "rheumd", "pud",
      "mld", "diabunc", "diabwc", "hp", "rend", "canc", "msld", "metacanc",
      "aids", "hypc", "hypunc"),
    function (x) ifelse(x == 1, "Yes", "No")
  ) 

# Create "derived" variables
data <- data %>%
  mutate(
    calendar_time = as.numeric(index_date - min(index_date)),
    index_month = as.integer(format(index_date, "%m")),
    death_month = as.integer(format(date_of_death,"%m")),
    os_days = pmax(0, date_of_death - index_date),
    
    ## Categorize BMI
    bmi_cat = case_when(
      bmi < 18.5 ~ "Underweight",
      bmi >= 18.5 & bmi < 25 ~ "Normal",
      bmi >= 25 & bmi < 30 ~ "Overweight",
      bmi >= 30 ~ "Obese",
      TRUE ~ NA_character_
    ),
    
    ## Combine comorbidities
    diab = case_when(
      diabunc == "Yes" | diabwc == "Yes" ~ "Yes",
      TRUE ~ "No"
    ),
    hyp = case_when(
      hypc == "Yes" | hypunc == "Yes" ~ "Yes",
      TRUE ~ "No"
    )
  ) %>%
  
  ## Create race/ethnicity variable
  ## Later to be created after imputation from imputed race + ethnicity
  add_race_ethnicity() 

  # Return
  return(data)
}

train_data <- clean_data(train_data)
```

## Label
```{r}
# Labels
## Categorical variables
demographic_cat_vars <- tribble(
  ~var, ~varlab,
  "sex", "Sex",
  "race", "Race",
  "ethnicity", "Ethnicity",
  "division", "Geographic division",
  "smoke", "Smoking",
  "race_ethnicity", 'Race/Ethnicity'
) %>% 
  mutate(group = "Demographics")

comorbidity_cat_vars <- tribble(
  ~var, ~varlab,
  "ami", "Acute myocardial infarction",
  "chf", "Congestive heart failure",
  "pvd", "Peripheral vascular disease",
  "cevd", "Cerebrovascular disease",
  "dementia", "Dementia",
  "cpd", "Chronic pulmonary disease",
  "rheumd", "Rheumatoid disease",
  "pud", "Peptic ulcer disease",
  "mld", "Mild liver disease",
  "diabunc", "Diabetes (no complications)",
  "diabwc", "Diabetes (complications)",
  "hp", "Hemiplegia or paraplegia",
  "rend", "Renal disease",
  "canc", "Cancer",
  "msld", "Moderate/severe liver disease",
  "metacanc", "Metastatic cancer",
  "aids", "AIDS/HIV",
  "hypunc", "Hypertension (no complications)",
  "hypc", "Hypertension (complications)",
  "diab", "Diabetes", # Combines diabunc and diabwc
  "hyp", "Hypertension", # Combine hypunc and hypc
) %>%
  mutate(group = "Comorbidities")

vital_cat_vars <- tribble(
  ~var, ~varlab,
  "bmi_cat", "Body Mass Index (BMI)",
) %>%
  mutate(group = "Vitals")

cat_vars <- bind_rows(demographic_cat_vars,
                      comorbidity_cat_vars,
                      vital_cat_vars)

## Continuous variables
demographic_continuous_vars <- tribble(
  ~var, ~varlab,
  "age", "Age",
  "calendar_time", "Calendar time"
) %>%
  mutate(group = "Demographics")

comorbidity_continuous_vars <- tribble(
  ~var, ~varlab,
  "cci", "CCI",
) %>%
  mutate(group = "Comorbidities")

vital_continuous_vars <- tribble(
  ~var, ~varlab,
  "bmi", "Body Mass Index (BMI)",
  "dbp", "Diastolic blood pressure",
  "sbp", "Systolic blood pressure",
  "hr", "Heart rate",
  "resp", "Respiration rate",
  "spo2", "Oxygen saturation",
  "temp", "Temperature",
) %>%
  mutate(group = "Vitals")

lab_vars <- tribble(
  ~var, ~varlab,
  "alt", "Alanine aminotransferase (ALT)",
  "ast", "Aspartate aminotransferase (AST)",
  "crp", "C-reactive protein (CRP)",
  "creatinine", "Creatinine",
  "ferritin", "Ferritin",
  "d_dimer", "Fibrin D-Dimer",
  "ldh", "Lactate dehydrogenase (LDH)",
  "lymphocyte", "Lymphocyte count",
  "neutrophil", "Neutrophil count",
  "pct", "Procalcitonin",
  "tni", "Troponin I",
  "plt", "Platelet count (PLT)",
  "wbc", "White blood cell count (WBC)"
) %>%
  mutate(group = "Labs")

continuous_vars <- bind_rows(
  demographic_continuous_vars,
  comorbidity_continuous_vars,
  vital_continuous_vars,
  lab_vars
)

# All variables
vars <- bind_rows(cat_vars,
                  continuous_vars)

get_var_labs <- function(v){
  vars$varlab[match(v, vars$var)]
}
```

# Preliminary data analysis
Before starting modeling, we will carefully inspect the data. This includes (i) checking the sample size, (ii) inspecting the extent of missing data, (iii) checking the distributions of possible predictor variables (and of death) including presence of potential outliers, (iv) assessing collinearities through plots of bivariate relationships between predictors, (v) summarizing the distribution of variables with a "Table 1", and (vi) looking at univariate fits between death and the continuous predictors to assess potential non-linearities and the number of knots that should be included when using splines.  

## Sample size

```{r}
train_data %>%
  count(name = "Sample size") %>% 
  mutate(Data = "Optum training set") %>%
  select(Data, `Sample size`) %>%
  kable() %>%
  kable_styling()
```

## Missing data

```{r}
missing_df <- train_data %>%
  select(one_of(vars$var)) %>%
  mutate_all(function (x) ifelse(is.na(x), 1, 0)) %>%
  mutate(id = factor(1:n())) %>%
  pivot_longer(cols = vars$var, names_to = "var", values_to = "missing") %>%
  left_join(vars, by = "var")
```

### Proportion missing
```{r, fig.height=8, fig.width = 8}
# Compute proportion missing
prop_missing <- missing_df %>%
  group_by(varlab) %>%
  summarise(prop = mean(missing))

# Plot
ggplot(prop_missing, aes(x = varlab, y = prop)) +
  geom_bar(stat = "identity") + 
  geom_text(aes(label = formatC(prop, format = "f", digits = 2)),
          nudge_y = .03, size = 3) +
ylim(c(0, 1)) +
xlab("") +
ylab("Proportion") +
coord_flip() +
scale_x_discrete(limits = rev(sort(vars$varlab)))
```

### Missing by patient
```{r, fig.height = 7, fig.width = 7}
ggplot(missing_df,
       aes(x = id, y = varlab,  fill = factor(missing))) +
  geom_raster() + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "bottom") +
  scale_fill_manual(name = "Missing",
                    values = c("lightgrey", "steelblue"),
                    labels = c("No", "Yes")) +
  scale_y_discrete(limits = rev(sort(vars$varlab)))
```

```{r, fig.height = 6, fig.width = 6}
missing_df %>% 
  # Count of missing by patient
  group_by(id) %>%
  summarise(n_missing = sum(missing),
            prop_missing = n_missing/n()) %>%
  
  # Plot
 ggplot(aes(x = prop_missing)) +
  geom_histogram(binwidth = .03, color = "white") +
  scale_x_continuous(breaks = seq(0, 1, .05)) +
  scale_y_continuous(n.breaks = 20) +
  xlab("Proportion of predictors that are missing") +
  ylab("Count") 
```

## Distributions

### Predictors
#### Categorical
```{r, fig.height = 10, fig.width = 11}
cat_var_df <-  train_data %>%
  select(one_of("ptid", cat_vars$var)) %>%
  pivot_longer(cols = cat_vars$var, names_to = "var", values_to = "value") %>%
  left_join(cat_vars, by = "var") %>%
  filter(!is.na(value)) %>%
  group_by(var, varlab, value) %>%
  summarise(n = n()) %>%
  group_by(varlab) %>%
  mutate(freq = n / sum(n)) %>%
  ungroup() %>%
  mutate(
    nudge_x = case_when(
      freq < 0.5 ~ 0.15,
      TRUE ~ -0.15
    )
  )

ggplot(cat_var_df,
       aes(x = freq, y = value)) +
  geom_point() + 
  geom_text(aes(label = formatC(freq, format = "f", digits = 2)),
            nudge_x = cat_var_df$nudge_x, size = 3.5) +
  facet_wrap(~varlab, scales = "free_y", ncol = 4) +
  xlim(0, 1) +
  xlab("Proportion") +
  ylab("") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        strip.text.x = element_text(size = 7))
```

#### Continuous
##### Box plot
```{r, fig.height = 7, fig.width = 10}
pivot_continuous_longer <- function(data, vars){
  col_names <- vars$var
  train_data %>%
    select(one_of("ptid", col_names)) %>%
    pivot_longer(cols = col_names, 
                 names_to = "var", 
                 values_to = "value") %>%
    left_join(vars, by = "var") %>%
    filter(!is.na(value)) 
}
continuous_var_df <- pivot_continuous_longer(train_data, 
                                             vars = continuous_vars)

plot_box <- function(data){
  ggplot(data, 
       aes(x = varlab, y = value)) +
  geom_boxplot(outlier.size = 1) + 
  facet_wrap(~varlab, scales = "free") +
  xlab("") +
  ylab("Value") +
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        strip.text = element_text(size = 7))
}
plot_box(continuous_var_df)

```

##### Histogram
```{r, fig.height = 7, fig.width = 8}
plot_hist <- function(data){
  ggplot(data,
       aes(x = value)) +
  geom_histogram(bins = 40, color = "white") +
  facet_wrap(~varlab, scales = "free", ncol = 4) + 
  xlab("") + ylab("Frequency") +
  theme(strip.text = element_text(size = 7))
}
plot_hist(continuous_var_df)
```

##### Outliers
Visual inspection of the box plots and histograms suggests that there are significant outliers in the labs. Let's look at how many observations lie above the 99th percentile of the data and the "outer fence" (defined as the 3rd quartile plus 3 time the interquartile range). We will then create new lab variables truncated from above at the outer fence and replot the histograms. 

```{r}
outer_fence <- function(v){
  q1 <- quantile(v, .25, na.rm = TRUE)
  q3 <- quantile(v, .75, na.rm = TRUE)
  iq <- (q3 - q1)
  return(as.numeric(q3 + 3 * iq))
}

format_percent <- function(x){
  paste0(formatC(100 * x, format = "f", digits = 1), "%")
}

train_data %>%
  select(one_of(lab_vars$var)) %>%
  pivot_longer(cols = lab_vars$var, names_to = "Lab") %>%
  filter(!is.na(value)) %>%
  group_by(Lab) %>%
  summarise(Maximum = max(value),
            `99%` = quantile(value, .99), 
            `Outer fence` = outer_fence(value),
            `% above outer fence` = format_percent(mean(value > outer_fence(value)))) %>%
  mutate(Lab = get_var_labs(Lab)) %>%
  kable() %>%
  kable_styling()
```

```{r}
# Truncate labs using outer fence
truncate_max <- function(v) outer_fence(v)

add_truncated_lab_vars <- function(data, v){
  for (i in 1:length(v)){ # Start loop over labs
    original_var <- v[i]
    truncated_var <- paste0(original_var, "_t")
    truncated_max_i <- truncate_max(data[[original_var]])
    data <- data %>% mutate(
      !!truncated_var := ifelse(get(original_var) > truncated_max_i, 
                                truncated_max_i, 
                                get(original_var))
    )
  } # End loop over labs
  return(data)
}
train_data <- add_truncated_lab_vars(train_data, v = lab_vars$var)
```

After truncating the labs, the probability distributions appear more reasonable. 

```{r, fig.height = 7, fig.width = 10}
lab_vars_t <- lab_vars %>%
  mutate(var = paste0(var, "_t"))
vars <- bind_rows(vars, lab_vars_t) 

continuous_vars_t <- bind_rows(
  demographic_continuous_vars,
  vital_continuous_vars,
  lab_vars_t
)

continuous_var_t_df <- pivot_continuous_longer(train_data, 
                                               vars = continuous_vars_t)
plot_hist(continuous_var_t_df)
```

### Outcomes
```{r, fig.height = 4, fig.width = 6}
train_data %>%
  count(died) %>%
  mutate(died = ifelse(died == 1, "Yes", "No"),
         prop = n/sum(n)) %>%
  ggplot(aes(x = died, y = prop)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = formatC(prop, format = "f", digits = 2)),
            nudge_y = .03, size = 3) +
  xlab("Died") +
  ylab("Proportion") 
```

#### Time to death
```{r, fig.height = 5, fig.width = 7}
train_data %>%
  mutate(months_to_death = death_month - index_month) %>%
  filter(!is.na(months_to_death)) %>%
  group_by(months_to_death) %>%
  tally() %>%
  
  # Plot
  ggplot(aes(x = factor(months_to_death), y = n)) +
  geom_bar(stat = "identity", position = "dodge") +
  xlab("Months from index date to death") +
  ylab("Count")
```

## Bivariate relationships
### Age and comorbidities
We start with the Charlson Comorbidity Index (CCI).

```{r, message = FALSE}
ggplot(train_data, aes_string(x = "age", y = "cci")) + 
  geom_point() +
  geom_smooth() +
  xlab(get_var_labs("age")) +
  ylab(get_var_labs("cci"))
```

Next, we will examine each comorbidity separately by plotting the probability that a patient has each comorbidity as a function of their age.

```{r, fig.height = 10, fig.width = 8, cache = TRUE, message = FALSE}
train_data[, c("age", comorbidity_cat_vars$var)] %>%
  pivot_longer(cols = comorbidity_cat_vars$var,
               names_to = "comorbidity") %>%
  mutate(value = ifelse(value == "No", 0L, 1L),
         comorbidity = get_var_labs(comorbidity)) %>%
  
  # Make plot
  ggplot(aes(x = age, y = value)) + 
    geom_smooth() +
    facet_wrap(~comorbidity, ncol = 4) +
   xlab(get_var_labs("age")) +
   ylab("Probability")
```

### Age and vitals
```{r, cache = TRUE, message = FALSE, fig.height = 5, fig.width = 8}
plot_scatter_continuous <- function(x_var, y_vars){
  train_data[, c(x_var, y_vars)] %>%
    pivot_longer(cols = all_of(y_vars)) %>%
    mutate(name = get_var_labs(name)) %>%
  
  # Make plot
  ggplot(aes_string(x = x_var, y = "value")) + 
    geom_smooth(se = FALSE) +
    facet_wrap(~name, ncol = 4, scales = "free_y") +
    xlab(get_var_labs(x_var)) +
    ylab("Value")
}

plot_scatter_continuous("age", vital_continuous_vars$var)
```

### Age and labs
```{r, message = FALSE, cache = TRUE, fig.height = 8, fig.width = 8}
plot_scatter_continuous("age", lab_vars_t$var) +
   theme(strip.text.x = element_text(size = 7))
```

### Comorbidities and labs/vitals
```{r, fig.height = 10, fig.width = 8, cache = TRUE, message = FALSE}
plot_scatter_continuous("cci", c(vital_continuous_vars$var, lab_vars_t$var)) +
  scale_x_continuous(breaks = sort(unique(train_data$cci))) +
  theme(strip.text.x = element_text(size = 7))
```

## Table 1 {#table1}
```{r tableOne}
# Select variables for table 1
varnames_to_remove <- c("race", "ethnicity", "bmi_cat", "hypunc", "hypc", 
                        "diabunc", "diabwc")

tbl1_varnames <- bind_rows(
  demographic_continuous_vars,
  demographic_cat_vars %>% arrange(varlab),
  comorbidity_cat_vars %>% arrange(varlab),
  comorbidity_continuous_vars,
  vital_continuous_vars %>% arrange(varlab),
  lab_vars %>% arrange(varlab)
) %>%
  filter(!var %in% varnames_to_remove) %>%
  pull(var)

tbl1_cat_varnames <- bind_rows(
  demographic_cat_vars,
  comorbidity_cat_vars,
  vital_cat_vars
) %>%
  filter(!var %in% varnames_to_remove) %>%
  pull(var)

tbl1_non_normal_varnames <- c(
  demographic_continuous_vars$var,
  vital_continuous_vars$var,
  comorbidity_continuous_vars$var,
  lab_vars$var
)
  
## Create a TableOne object
tbl1_train <- train_data %>%
  select(one_of(tbl1_varnames, "died")) %>%
  rename_with(get_var_labs, .cols = all_of(tbl1_varnames)) %>%
  rename(Survivor = died) %>%
  CreateTableOne(vars = get_var_labs(tbl1_varnames), 
                 factorVars = get_var_labs(tbl1_cat_varnames), 
                 strata = "Survivor",  addOverall = TRUE, 
                 data = .)

## Print table 1
print(tbl1_train, nonnormal = get_var_labs(tbl1_non_normal_varnames),  
      cramVars = c("Sex"),
      contDigits = 1, missing = TRUE, printToggle = FALSE) %>%
  set_colnames(c("Overall", "Survivor", "Non-survivor",
                "p", "Test", "Missing")) %>%
  kable() %>%
  kable_styling()
```

## Transformations of continuous variables {#variable-transformations} 
The functional form of the relationship between mortality and the continuous variables is assessed using a series of univariate fits. We mainly rely on visual inspection of the graphs but also report the Bayesian information criterion (BIC).

```{r}
tryNULL <- function(expr) {
  res <- NULL
  try(res <- expr)
  return(res)
}

fit_univariate_logit <- function(var, data, spline){
  make_f <- function(rhs){
    as.formula(paste("died", rhs, sep =" ~ "))
  }
  
  fit_logit <- function(f, data){
    lrm(f, data = data)
  }
  
  list(
    `Linear` = fit_logit(make_f(var), data),
    `Spline 3 knots` = fit_logit(make_f(sprintf("rcs(%s, 3)", var)), data),
    `Spline 4 knots` = fit_logit(make_f(sprintf("rcs(%s, 4)", var)), data),
    `Spline 5 knots` = fit_logit(make_f(sprintf("rcs(%s, 5)", var)), data)
  )
}

predict_univariate_logit <- function(models, var, var_values, type = "response"){
  newdata <- data.frame(var = var_values)
  colnames(newdata) <- var
  pred_df <- map_dfc(models, function(x) {
    p <- tryNULL(predict(x, newdata = newdata, type = type))
  }) 
  model_names <- colnames(pred_df)
  pred_df %>%
    mutate(var = var_values) %>%
    pivot_longer(cols = model_names,
               names_to = "Model",
               values_to = "y")
}

midpoint <- function(x, digits = 2){
  lower <- as.numeric(gsub(",.*", "", gsub("\\(|\\[|\\)|\\]", "", x)))
  upper <- as.numeric(gsub(".*,", "", gsub("\\(|\\[|\\)|\\]", "", x)))
  return(round(lower+(upper-lower)/2, digits))
}

bin_y <- function(var, var_values){
  data <- train_data[, c(var, "died")] %>%
    filter(!is.na(get(var)))
  data <- data %>%
    mutate(x_cat = cut(get(var), breaks = 20),
           x_midpoint = midpoint(x_cat)) %>%
    group_by(x_midpoint) %>%
    summarise(y = mean(died),
              n = n())
  colnames(data)[1] <- var
  return(data)
}

plot_univariate_logit <- function(models, var, var_values, var_lab = "Variable",
                                  type = "response", ylab = "Probability of death"){
  # Plotting data
  predicted_probs <- predict_univariate_logit(models, var, var_values, type = type)
  ylab <- switch(type,
                 "lp" = "Log odds",
                 "fitted" = "Probability of death",
                 stop("Type must be 'lp' or 'fitted'")
  )
  binned_y <- bin_y(var, var_values)
  if (type == "lp"){
    binned_y$y <- ifelse(binned_y$y == 0, .001, binned_y$y)
    binned_y$y <- ifelse(binned_y$y == 1, .99, binned_y$y)
    binned_y$y <- qlogis(binned_y$y)
  }
  
  # Plotting scales
  y_min <- min(c(binned_y$y, predicted_probs$y))
  y_max <- max(c(binned_y$y, predicted_probs$y))
  size_breaks <- seq(min(binned_y$n), max(binned_y$n),
                     length.out = 6)
  
  # Plot
  ggplot(predicted_probs,
       aes(x = var, y = y)) +
    geom_line() +
    geom_point(data = binned_y, aes_string(x = var, y = "y", size = "n")) +
    facet_wrap(~Model, ncol = 2) +
    xlab(var_lab) +
    ylab(ylab) +
    ylim(floor(y_min), ceiling(y_max)) +
    scale_size(name = "Sample size", range = c(0.3, 3), 
               breaks = round(size_breaks, 0)) 
}

make_seq <- function(var){
  var_min <- min(train_data[[var]], na.rm = TRUE)
  var_max <- max(train_data[[var]], na.rm = TRUE)
  seq(var_min, var_max, length.out = 100)
}

evaluate_univariate_logit <- function(var, print = TRUE){
  var_values = make_seq(var)
  var_lab = get_var_labs(var)
  
  # Do evaluations
  fits <- fit_univariate_logit(var, data = train_data)
  p_link <- plot_univariate_logit(fits, var, var_values, var_lab, type = "lp")
  p_probs <- plot_univariate_logit(fits, var, var_values, var_lab, type = "fitted")
  bic <- unlist(lapply(fits, function(z) tryNULL(BIC(z))))
  
  # Print and return
  if (print){
    print(p_link)
    print(p_probs)
    print(bic)
  }
  return(list(fits = fits, p_link = p_link, p_probs = p_probs,
              bic = bic))
}

dd <- datadist(train_data)
options(datadist = "dd")
```

### Demographics
#### Age 
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_age <- evaluate_univariate_logit("age")
```

#### Calendar time
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_calendar_time <- evaluate_univariate_logit("calendar_time")
```

### Vitals
#### Body Mass Index

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_bmi <- evaluate_univariate_logit("bmi")
```

#### Diastolic blood pressure
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_dbp <- evaluate_univariate_logit("dbp")
```

#### Systolic blood pressure
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_sbp <- evaluate_univariate_logit("sbp")
```

#### Heart rate
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_hr <- evaluate_univariate_logit("hr")
```

#### Respiration rate
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_resp <- evaluate_univariate_logit("resp")
```

#### Oxygen saturation (%)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_spo2 <- evaluate_univariate_logit("spo2")
```

#### Temperature
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_temp <- evaluate_univariate_logit("temp")
```

### Labs
#### Alanine aminotransferase (U/L) {#transform-continuous-alt}
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_alt <- evaluate_univariate_logit("alt")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_alt_t <- evaluate_univariate_logit("alt_t")
```

#### Aspartate  aminotransferase (U/L)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ast <- evaluate_univariate_logit("ast")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ast_t <- evaluate_univariate_logit("ast_t")
```

#### C-reactive protein (mg/L)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_crp <- evaluate_univariate_logit("crp")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_crp_t <- evaluate_univariate_logit("crp_t")
```

#### Creatinine (mg/dL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_creatinine <- evaluate_univariate_logit("creatinine")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_creatinine_t <- evaluate_univariate_logit("creatinine_t")
```

#### Ferritin (ng/mL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ferritin <- evaluate_univariate_logit("ferritin")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ferritin_t <- evaluate_univariate_logit("ferritin_t")
```

#### Fibrin D-Dimer (ng/mL)
```{r, fig.height = 3, fig.width = 7, message = FALSE}
uv_d_dimer <- evaluate_univariate_logit("d_dimer")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_d_dimer_t <- evaluate_univariate_logit("d_dimer_t")
```

#### Lactate dehydrogenase (U/L)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ldh <- evaluate_univariate_logit("ldh")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_ldh_t <- evaluate_univariate_logit("ldh_t")
```

#### Lymphocyte count (10^3/uL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_lymphocyte <- evaluate_univariate_logit("lymphocyte")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_lymphocyte_t <- evaluate_univariate_logit("lymphocyte_t")
```

#### Neutrophil count (10^3/uL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_neutrophil <- evaluate_univariate_logit("neutrophil")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_neutrophil_t <- evaluate_univariate_logit("neutrophil_t")
```

#### Procalcitonin (ng/mL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_pct <- evaluate_univariate_logit("pct")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_pct_t <- evaluate_univariate_logit("pct_t")
```

#### Troponin I (ng/mL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_tni <- evaluate_univariate_logit("tni")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_tni_t <- evaluate_univariate_logit("tni_t")
```

#### Platelet count (10^3/uL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_plt <- evaluate_univariate_logit("plt")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_plt_t <- evaluate_univariate_logit("plt_t")
```

#### White blood cell count (10^3/uL)
```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_wbc <- evaluate_univariate_logit("wbc")
```

```{r, fig.height = 5, fig.width = 7, message = FALSE}
uv_wbc_t <- evaluate_univariate_logit("wbc_t")
```

# Data preprocessing 
## Candidate variables for modeling
Variables that will be candidates for inclusion in our model and used during variable selection are specified here. We will combine race and ethnicity into a single variable, but will wait to do this until after multiple imputation (see next section). Alanine aminotransferase (ALT) will also be excluded due to (i) a strong correlation with AST (`r formatC(cor(train_data$alt, train_data$ast, use = "complete.obs"), format = "f", digits = 2)`) and weak univariate associations with mortality (see [above](#transform-continuous-alt)).

```{r}
demographics_to_include <- c("age", "sex", "race", "ethnicity", "division",
                             "smoke", "calendar_time")
comorbidities_to_include <- comorbidity_cat_vars %>%
  filter(!var %in% c("diabunc", "diabwc", "hypunc", "hypc")) %>%
  pull(var) %>%
  c("diab", "hyp")
vitals_to_include <- c("bmi", "temp", "hr", "resp", "spo2", "sbp")
labs_to_include <- c("crp_t", "tni_t", "ast_t", "ferritin_t",
                     "creatinine_t", "ldh_t", "lymphocyte_t", "neutrophil_t",
                     "plt_t", "wbc_t")
vars <- vars %>%
  mutate(include = ifelse(var %in% c(demographics_to_include, 
                                     comorbidities_to_include,
                                     vitals_to_include, 
                                     labs_to_include),
                          1, 0))
get_included_vars <- function(){
  vars[vars$include == 1, ]$var
}

make_rhs <- function(vars){
  as.formula(paste0("~", paste(vars, collapse = " + ")))
}
candidate_model_rhs <- make_rhs(get_included_vars()) 
```

## Missing data imputation
Imputation will be performed using multivariate imputation by chained equations (MICE). Before imputing, we will first re-level variables so that we have preferred reference categories. 

```{r}
train_data <- train_data %>% mutate(
  sex = relevel(factor(sex), ref = "Male"),
  division = relevel(factor(division), ref = "Pacific"),
  smoke = relevel(factor(smoke), ref = "Never"),
  bmi_cat = relevel(factor(bmi_cat), ref = "Normal")
)
```

We can then impute using the `mice()` function.

```{r, cache = TRUE, results = "hide"}
# Run MICE algorithm
mice_out <- train_data %>%
  select(c(one_of(get_included_vars()))) %>%
  mutate_if(is.character, as.factor) %>%
  mice(m = n_imputations, maxit = 5) 

## Save variables for test set imputation
mice_vars <- c(get_included_vars())

# Append datasets and add death
mi_df <- complete(mice_out, action = "long", include = TRUE) %>%
  as_tibble() %>%
  mutate(died = rep(train_data$died, mice_out$m + 1))

# To compare MICE to aregImpute
# areg_out <-  aregImpute(update.formula(candidate_model_rhs, ~.), 
#                                        n.impute = 2, data = train_data)
```

## Imputation diagnostics
The distributions of the imputed and observed data are compared as a diagnostic for the imputation. They look pretty similar suggesting that there is nothing terribly wrong with the imputation.

```{r}
make_imp_df <- function(object){
  # Get imputations
  if (inherits(object, "mids")){
    imp <- object$imp
  } else{ # aregImpute
   imp <- object$imputed 
   for (i in 1:length(imp)){
     cat_levels_i <- object$cat.levels[[i]]
     if (!is.null(cat_levels_i) && !is.null(imp[[i]])){
       levels <- sort(unique(c(imp[[i]])))
       imp[[i]] <- apply(imp[[i]], 
                         2, 
                         function(x) factor(x, levels = levels,
                                            labels = cat_levels_i))
     }
   }
  }
  
  # Create list of data frames
  is_numeric <- sapply(imp, function (x) is.numeric(x[, 1]))
  continuous_df <- vector(mode = "list", length = sum(is_numeric))
  cat_df <- vector(mode = "list", length = sum(!is_numeric))
  continuous_cntr <- 1
  cat_cntr <- 1
  for (i in 1:length(imp)){
    if(!is.null(nrow(imp[[i]])) && nrow(imp[[i]]) > 0 ){
        imp_i_df <- data.frame(var = names(imp)[i],
                               imp = rep(1:ncol(imp[[i]]), each = nrow(imp[[i]])),
                               value = c(as.matrix(imp[[i]]))) %>% 
          as_tibble()
        
    } else{
      imp_i_df <- NULL
    }
    if (is_numeric[i]){
      continuous_df[[continuous_cntr]] <- imp_i_df
      continuous_cntr <- continuous_cntr + 1
    } else{
      cat_df[[cat_cntr]] <- imp_i_df
      cat_cntr <- cat_cntr + 1
    }
  } 
  
  # Row bind data frames
  continuous_df = bind_rows(continuous_df) %>%
    mutate(obs = "Imputed",
           varlab = get_var_labs(var)) 
  
  cat_df = bind_rows(cat_df) %>%
    mutate(obs = "Imputed",
           varlab = get_var_labs(var)) 
              
  # Return
  return(list(continuous = continuous_df,
              cat = cat_df))
}
imp_df <- make_imp_df(mice_out)
#imp_df <- make_imp_df(areg_out)
```

Note that there are some differences for sex, but this is because there are very few (n = `sum(is.na(train_data$sex))`) observations with missing sex.

```{r, fig.height = 7, fig.width = 8}
# Plot continuous variables
## Data for plotting
obsimp_df_continuous <- bind_rows(
  imp_df$continuous,
  continuous_var_df %>%
    select(var, value, varlab) %>%
    mutate(imp = 0, obs = "Observed")
) %>%
  mutate(imp = ifelse(imp == 0, "Observed", paste0("Imputation ", imp))) %>%
  filter(var %in% unique(imp_df$continuous$var))
  
## Plot
ggplot(obsimp_df_continuous,
       aes(x = value, col = imp)) +
  geom_density(position = "jitter") +
  facet_wrap(~varlab, scales = "free", ncol = 3) +
  xlab("") + ylab("Density") +
  scale_color_discrete(name = "") +
  theme(legend.position = "bottom")
```

```{r, fig.height = 6, fig.width = 8}
# Plot categorical variables
## Data for plotting
obsimp_df_cat <- 
  bind_rows(
    imp_df$cat %>%
      group_by(var, varlab, value, imp) %>%
      summarise(n = n()) %>%
      group_by(var, varlab, imp) %>%
      mutate(freq = n / sum(n)),
    cat_var_df %>%
      select(var, value, varlab, n, freq) %>%
      mutate(imp = 0, obs = "Observed")
  ) %>%
    mutate(imp = ifelse(imp == 0, "Observed", paste0("Imputation ", imp))) %>%
    filter(var %in% unique(imp_df$cat$var))

# Plot
ggplot(obsimp_df_cat, 
       aes(x = value, y = freq, fill = imp)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_wrap(~varlab, scales = "free_x") +
  scale_fill_discrete(name = "") +
  xlab("") +
  ylab("Proportion") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```

## Recoding categorical variables
We create the race/ethnicity variable after imputation of missing values of race and ethnicity. We will also combine the diabetes and hypertension variables.

```{r}
mi_df <- mi_df %>% 
  add_race_ethnicity() 

prop.table(table(mi_df %>% filter(.imp == 0) %>% pull(diab)))
prop.table(table(mi_df %>% filter(.imp == 0) %>% pull(hyp)))
```

Now lets use the combined race and ethnicity category in our model.  

```{r}
vars <- vars %>%
  mutate(include = case_when(
      var == "race_ethnicity" ~ 1,
      var == "race" ~ 0,
      var == "ethnicity" ~ 0,
      TRUE ~ include
    )
  )
  
candidate_model_rhs <- make_rhs(get_included_vars())
```

Finally, we will (i) add the new race/ethnicity variable to the "MICE" object and (ii) create a list of imputed datasets for analysis.

```{r, cache = TRUE}
mice_out <- as.mids(mi_df)
mi_list <- mi_df %>% 
  filter(.imp > 0) %>% 
  split(list(.$.imp))
```

# Variable selection
We select variables for inclusion in the model by repeatedly fitting a logistic regression with a group lasso penalty. Each group lasso model is trained using 10-fold cross validation to select a value of the penalty parameter, lambda. Coefficients are extracted from the fit with `lambda = 1se`; that is, the model with deviance within one standard error of the minimum deviance. This process was repeated $N$ times for each of the $M$ imputed datasets. Variables with non-zero coefficients in at least 90 percent of the $N \times M$ iterations were deemed suitable for inclusion in the model. 

We now setup the group lasso model, which will be implemented with `oem`. The continuous variables are transformed using restricted cubic splines with 3 knots.

```{r}
candidate_model_rhs <- candidate_model_rhs %>%
  update.formula( ~. + rcs(age, 3) - age +
                       rcs(calendar_time, 3) - calendar_time +
                       rcs(bmi, 3) - bmi +
                       rcs(temp, 3) - temp +
                       rcs(hr, 3) - hr +
                       rcs(resp, 4) - resp +
                       rcs(sbp, 3) - sbp +
                       rcs(spo2, 3) - spo2 +
                       rcs(crp_t, 3) - crp_t +
                       rcs(tni_t, 3) - tni_t +
                       rcs(ast_t, 3) - ast_t +
                       rcs(creatinine_t, 3) - creatinine_t +
                       rcs(ferritin_t, 3) - ferritin_t +
                       rcs(ldh_t, 3) - ldh_t,
                       rcs(lymphocyte_t, 3) - lymphocyte_t +
                       rcs(neutrophil_t, 3) - neutrophil_t +
                       rcs(plt_t, 3) - plt_t +
                       rcs(wbc_t, 3) - wbc_t)
```

With `oem` we need to create an `x` matrix since there is no formula interface.

```{r}
rename_rcs <- function(v){
  rcs_ind <- grep("rcs", v)
  v[rcs_ind] <- sub("rcs.*)", "", v[rcs_ind])
  return(v)
}

rename_terms <- function(v){
  v <- gsub(" ", "_", v)
  v <- gsub("-", "", v)
  v <- gsub("/", "", v)
  v <- rename_rcs(v)
  return(v)
}

make_x <- function(data, rhs){
  x <- model.matrix(rhs, data)
  assign <- attr(x, "assign")
  colnames(x) <- rename_terms(colnames(x))
  x <- x[, -1]
  attr(x, "assign") <- assign[-1]
  return(x)
}

# List of x and y for each imputed dataset
x <- mi_list %>% map(function(data) make_x(data, candidate_model_rhs))
y <- mi_list %>% map(function(x) x[["died"]])
```

To make the graphs look nice, we will import labels for the model terms. 

```{r}
terms <- read.csv("risk-factors-terms.csv") %>%
  left_join(vars[, c("var", "group")], by = "var")

get_term_labs <- function(v, term_name = "term"){
  terms$termlab[match(v, terms[[term_name]])]
}

match_terms_to_vars <- function(t){
  terms$var[match(t, terms$term)]
}
```

Finally, we repeatedly train the group lasso model with cross-validation.

```{r, cache = TRUE}
# Number of folds for cross-validation
n_folds <- 10

# Threshold for variable inclusion
inclusion_threshold <- 0.9

# Matrix to store inclusion results
inclusion_sim <- matrix(0,  ncol = ncol(x[[1]]) + 1, 
                        nrow = n_rep * n_imputations)

# Groups
groups <- attr(x[[1]], "assign") 

# Convenience function to extract coefficients from group-lasso
coef_cv_oem <- function(object){
  coef <- object$oem.fit$beta$grp.lasso
  lse_ind <- which(object$lambda[[1]] == object$lambda.1se.models)
  return(coef[, lse_ind])
}

# Variable selection via group-lasso
cntr <- 1
for (i in 1:n_imputations){
  for (j in 1:n_rep){
    
    # Cross-validation
    oem_cvfit <- cv.oem(x = x[[i]], y = y[[i]], 
                        penalty = "grp.lasso", 
                        groups = groups, 
                        family = "binomial",
                        type.measure = "deviance",
                        nfolds = n_folds
                        )
  
    # Count nonzero coefficients 
    inclusion_sim[cntr, which(coef_cv_oem(oem_cvfit) != 0)] <- 1
    
    # Iterate
    cntr <- cntr + 1
  } # End repeated CV loop
} # End imputation loop 
```

We can then plot the proportion of times that coefficients for each variable were nonzero.

```{r, fig.height = 6, fig.width = 7}
# Percentage of simulations each term is included
inclusion_sim <- inclusion_sim[, -1] # Remove intercept
colnames(inclusion_sim) = colnames(x[[1]])

inclusion_summary <- tibble(term = colnames(inclusion_sim), 
                            prob = apply(inclusion_sim, 2, mean)) 
model_terms <- inclusion_summary %>%
  filter(prob >= inclusion_threshold) %>%
  pull(term)

# Percentage of simulations each variable is included
inclusion_summary <- inclusion_summary %>%
  mutate(var = match_terms_to_vars(term)) %>%
  mutate(varlab = get_var_labs(var)) %>% 
  distinct(prob, var, varlab)

# Plot
ggplot(inclusion_summary,
       aes(x = reorder(varlab, prob), y = prob)) +
  geom_bar(stat = "identity") + 
  geom_hline(yintercept = inclusion_threshold, linetype = "dotted", 
                color = "red", size = 1) +
  ylab("Probability of inclusion") +
  coord_flip() +
  theme(axis.title.y = element_blank())
```

# Model interpretation
## Model terms and data
Variables are included in the model based on the group lasso simulation implemented above. 

```{r}
vars_to_exclude <- inclusion_summary %>%
  filter(prob < inclusion_threshold) %>%
  pull(var) %>%
  setdiff("sex") # Keep sex even if not picked by group lasso

remove_terms_from_rhs <- function(f, vars_to_exclude){
  # First convert formula to string separated by +
  f_string <- Reduce(paste, deparse(f))
  f_string <- gsub("~", "", f_string)
  f_string <- gsub(" ", "", f_string)
  
  # Then convert string to vector
  f_vec <-   unlist(strsplit(f_string, "\\+"))
  pattern_to_exclude <- paste(vars_to_exclude, collapse = "|")
  f_vec <- f_vec[!grepl(pattern_to_exclude, f_vec)]
  
  # Convert string back to formula
  f_new <- paste0("~", paste(f_vec, collapse = " + "))
  return(as.formula(f_new))
}

model_rhs <- remove_terms_from_rhs(candidate_model_rhs, vars_to_exclude)
```

```{r}
label(mi_df) <- map(colnames(mi_df), 
                    function(x) label(mi_df[, x]) <- get_var_labs(x))
dd <- datadist(mi_df, adjto.cat = "first")
options(datadist = "dd")
```

## Fit
As described in the paper, five models are fit that include the following predictors: (i) age only, (ii) comorbidities only, (iii) all demographics (and calendar time), and (iv) demographics (and calendar time) and comorbidities, and (v) all variables selected by the group lasso. 

```{r}
# The four models
lrm_names <- c("Age only",
               "Comorbidities only",
               "All demographics",
               "Demographics and comorbidities",
               "All variables")

## (1): fit_age: Only includes age
f_lrm_age <- died ~ rcs(age, 3)
lrm_fit_age <- fit.mult.impute(f_lrm_age, fitter = lrm, xtrans = mice_out, pr = FALSE,
                               x = TRUE, y = TRUE)

## (2): fit_c: Only includes comorbidities
c_vars <- vars %>%
  filter(group == "Comorbidities" & include == 1 & !var %in% vars_to_exclude) %>%
  pull(var)
f_lrm_c <- as.formula(paste0("died ~", paste(c_vars, collapse = "+")))
lrm_fit_c <- fit.mult.impute(f_lrm_c, fitter = lrm, xtrans = mice_out, 
                             pr = FALSE, x = TRUE, y = TRUE) 

## (3): fit_d: All demographics including age
f_lrm_d <- update.formula(f_lrm_age, ~. + sex + rcs(calendar_time, 3) + 
                          race_ethnicity + division)
lrm_fit_d <- fit.mult.impute(f_lrm_d, fitter = lrm, xtrans = mice_out, pr = FALSE,
                             x = TRUE, y = TRUE)

## (4): fit_dc: Demographics and comorbidities
f_lrm_dc <- update.formula(f_lrm_d, 
                           as.formula(paste0("~.+", paste(c_vars, collapse = "+"))))
lrm_fit_dc <- fit.mult.impute(f_lrm_dc, fitter = lrm, xtrans = mice_out, pr = FALSE,
                              x = TRUE, y = TRUE)

## (5): fit_all: The main model including demographics, comorbidities, vitals, and labs
f_lrm_all <- update.formula(model_rhs, died ~ .)
lrm_fit_all <- fit.mult.impute(f_lrm_all, fitter = lrm, xtrans = mice_out, 
                               pr = FALSE, x = TRUE, y = TRUE)

### Note that we can also estimate the models with stats::glm
glm_fits_all <- mi_list %>%
  map(function (x) glm(f_lrm_all, data = x, family = "binomial")) 
glm_fit_all <- glm_fits_all %>% pool()
```

We will print the results of the full model for the interested reader
```{r}
lrm_fit_all
```

## Collinearity 
Let's examine the extent to which our predictors are collinear: for categorical and continuous variables, we use an anova model; for categorical and categorical variables, we use Cramer's V; and for continuous and continuous variables, we use spearman correlation. (Note that this takes a long time to run and could probably be made more efficient.)

```{r}
## from https://stackoverflow.com/questions/52554336/plot-the-equivalent-of-correlation-matrix-for-factors-categorical-data-and-mi
mixed_assoc <- function(df, cor_method = "spearman", adjust_cramersv_bias = TRUE){
  df_comb <- expand.grid(names(df), names(df),  stringsAsFactors = F) %>% 
    set_names("X1", "X2")
  is_nominal <- function(x) inherits(x, c("factor", "character"))
  # https://community.rstudio.com/t/why-is-purr-is-numeric-deprecated/3559
  # https://github.com/r-lib/rlang/issues/781
  is_numeric <- function(x) { is.integer(x) || is_double(x)}
  f <- function(x_name, y_name) {
    x <-  pull(df, x_name)
    y <-  pull(df, y_name)
    result <- if(is_nominal(x) && is_nominal(y)){
        # use bias corrected cramersV as described in https://rdrr.io/cran/rcompanion/man/cramerV.html
        cv <- cramerV(as.character(x), as.character(y), 
                      bias.correct = adjust_cramersv_bias)
        data.frame(x_name, y_name, assoc = cv, type = "cramersV")
    } else if(is_numeric(x) && is_numeric(y)){
        correlation <- cor(x, y, method = cor_method, use = "complete.obs")
        data.frame(x_name, y_name, assoc = correlation, type = "correlation")
    } else if(is_numeric(x) && is_nominal(y)){
        # from https://stats.stackexchange.com/questions/119835/correlation-between-a-nominal-iv-and-a-continuous-dv-variable/124618#124618
        r_squared <- summary(lm(x ~ y))$r.squared
        data.frame(x_name, y_name, assoc = sqrt(r_squared), type = "anova")
    } else if(is_nominal(x) && is_numeric(y)){
        r_squared <- summary(lm(y ~ x))$r.squared
        data.frame(x_name, y_name, assoc = sqrt(r_squared), type = "anova")
    } else {
        warning(paste("unmatched column type combination: ", class(x), class(y)))
    }
    # finally add complete obs number and ratio to table
    result %>% 
      mutate(
        complete_obs_pairs = sum(!is.na(x) & !is.na(y)),
        complete_obs_ratio = complete_obs_pairs/length(x)) %>%
      rename(x = x_name, y = y_name)
  }
  # apply function to each variable combination
  map2_df(df_comb$X1, df_comb$X2, f)
}
```

```{r, cache = TRUE, eval = TRUE, fig.height = 8}
# Create correlation matrix of associations
corr_mat <- mi_df %>% 
  filter(.imp == 1) %>% 
  select(any_of(get_included_vars())) %>%
  mixed_assoc() %>%
  select(x, y, assoc) %>%
  pivot_wider(names_from = y, values_from = assoc) %>%
  column_to_rownames("x") %>%
  as.matrix

# Make tile plot
m <- abs(corr_mat)
heatmap_df <- tibble(row = rownames(m)[row(m)], 
                     col = colnames(m)[col(m)], corr = c(m)) %>%
  mutate(row = get_var_labs(row),
         col = get_var_labs(col))
heatmap_df %>%
  ggplot(aes(x = row, y = col, fill = corr)) + 
  geom_tile() + 
  scale_fill_continuous("Correlation") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title = element_blank()) 
```

## Variable importance {#variable-importance}
Variable importance is assessed with a Wald test using `rms::anova()`. 

```{r varImportance}
# Compute variable important with Wald chi-square
lrm_anova_all <- anova(lrm_fit_all)

# Plot the result
## Make data frame
lrm_anova_all_df <- lrm_anova_all %>% 
  as_tibble() %>%
  mutate(var = gsub(" ", "", rownames(lrm_anova_all)),
         varlab = get_var_labs(var),
         value = as.double(`Chi-Square` - `d.f.`)) %>%
  filter(!var %in% c("TOTAL", "Nonlinear", "TOTALNONLINEAR")) 

## Plot
ggplot(lrm_anova_all_df, aes(x = value, y = reorder(varlab, value))) +
  geom_point() +
  theme(axis.title.y = element_blank()) +
  xlab(expression(chi^2-df)) 
```


```{r}
my_datatable <- function(data, filename) {
  datatable(
    data,
    rownames = FALSE,
    filter = "top",
    extensions = "Buttons",
    options = list(pageLength = 20,
                    dom = "Bfrtip",
                    buttons = list(list(extend = "copy"),
                                   list(extend = "csv", filename = filename)) 
    ))
}

lrm_anova_all_df %>%
  select(Variable = varlab, `Chi-Square`, `DF` = `d.f.`, 
                   `Chi-Square - DF` = value, `P`)  %>%
  arrange(desc(`Chi-Square - DF`)) %>%
  my_datatable(filename = "varimp") %>%
  formatRound(c("Chi-Square", "Chi-Square - DF", "P"), 
              3)
```

## Summary of odds ratios
The model is summarized with odds ratios using `rms::summary()`. We will start by assessing the full model. Next, since labs and vitals may themselves be "caused" by comorbidities, we will see how the odds ratios for the comorbidities change after dropping labs and vitals from the model. 

### Full model {#summary-or-full}
The plot displays odds ratios and 95% confidence intervals for each variable in the full model. Note that odds ratios for continuous variables reflect a change from `upper:lower`. For example, the odds ratio for age (`75:49`) is for a change from age 49 to age 75.

```{r oddsRatio, fig.height = 6}
lrm_summary_all <- summary(lrm_fit_all)

# Odds ratios
format_or_range <- function(x, term){
  case_when(
    x < 10 ~ formatC(x, format = "f", digits = 2),
    term == "temp" ~ formatC(x, format = "f", digits = 1),
    TRUE ~ formatC(x, format = "f", digits = 0)
  )
}

make_tidy_or <- function(object, model_name = NULL){
  if (is.null(model_name)) model_name <- "Model"
  object %>%
    as.data.frame() %>%
    as_tibble() %>%
    mutate(term = rownames(object),
           High = format_or_range(High, term),
           Low = format_or_range(Low, term),
           termlab = get_term_labs(term, "term2"),
           termlab = ifelse(!is.na(`Diff.`), 
                            paste0(termlab, " - ", High, ":", Low),
                            termlab),
           or = exp(Effect),
           or_lower = as.double(exp(`Lower 0.95`)),
           or_upper = exp(`Upper 0.95`)) %>%
    filter(Type == 1) %>%
    select(term, termlab, or, or_lower, or_upper) %>%
    arrange(-or) %>%
    mutate(model = model_name)
}
lrm_or_all <- make_tidy_or(lrm_summary_all, "All variables") 

# Odds ratio plot
ggplot(lrm_or_all, 
       aes(x = or, y = reorder(termlab, or))) +
  geom_point() +
  geom_errorbarh(aes(xmax = or_upper, xmin = or_lower,
                     height = .2)) +
  geom_vline(xintercept = 1, linetype = "dashed", col = "grey") + 
  theme(axis.title.y = element_blank()) +
  xlab("Odds ratio")
```

### Comparison of model with and without vitals + labs

```{r, fig.width = 7, fig.height = 8}
lrm_summary_dc <- summary(lrm_fit_dc)
lrm_or_dc <- make_tidy_or(lrm_summary_dc, "Demographics + comorbidities")

# Odds ratio comparison plot
lrm_or_comp <- bind_rows(lrm_or_all, lrm_or_dc) %>%
  filter(term %in% 
           terms[terms$group %in% c("Demographics", "Comorbidities"), ]$term2) %>%
  mutate(termlab = factor(termlab),
         termlab = reorder(termlab, or, function (x) -mean(x)))

ggplot(lrm_or_comp, 
       aes(x = termlab, y = or, col = model)) +
  geom_point(position = position_dodge(width = 1)) +
  geom_errorbar(aes(ymax = or_upper, ymin = or_lower,
                     width = .2), position = position_dodge(width = 1)) +
  facet_wrap(~termlab, strip.position = "left", ncol = 1, scales = "free_y") + 
  geom_hline(yintercept = 1, linetype = "dashed") + 
  theme(axis.title.y = element_blank()) +
  scale_color_discrete(name = "Model") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        strip.text.y.left = element_text(hjust = 0, vjust = 1, 
                                         angle = 0, size = 8),
        legend.position = "bottom") +
  ylab("Odds ratio") +
  coord_flip()

# Results in a table
lrm_or_comp %>%
  select(-term) %>%
  rename(Term = termlab,
         `Odds ratio` = or,
         `Odds ratio (lower)` = or_lower,
         `Odds ratio (upper)` = or_upper,
         Model = model) %>%
  my_datatable(filename = "coef_comp") %>%
  formatRound(c("Odds ratio", "Odds ratio (lower)", "Odds ratio (upper)"),  
                4)
```

## Predicted log odds
One limitation of the odds ratio plots is that it is hard to examine the potentially non-linear relationships between mortality and the continuous variable. The `rms::Predict()` function is especially helpful in this regard. We use it to vary all of the predictors and plot predicted log odds across the different values of each predictor. 

Each prediction is made with all other variables at their "Adjust to" value as specified with `datadist()` above.

```{r}
t(dd$limits) %>%
  as_tibble() %>%
  mutate(Variable = get_var_labs(colnames(dd$limits))) %>%
  relocate(Variable, .before = "Low:effect") %>%
  filter(!is.na(Variable)) %>%
  arrange(Variable) %>%
  kable() %>%
  kable_styling()
```

Let's make the predictions.

```{r, fig.height = 14, fig.width = 9}
lrm_log_odds <- Predict(lrm_fit_all, ref.zero = TRUE)

# Get plotting data
p_log_odds <- ggplot(lrm_log_odds, sepdiscrete = "list")

# Continuous plot
log_odds_limit <- max(ceiling(c(abs(p_log_odds$continuous$data$lower), 
                                abs(p_log_odds$continuous$data$upper))))
log_odds_breaks <- seq(-log_odds_limit, log_odds_limit, 2)
p_log_odds_continuous <- p_log_odds$continuous$data %>%
  as_tibble() %>%
  mutate(varlab = get_var_labs(.predictor.)) %>%
  ggplot(aes(x = .xx., y = yhat)) +
  facet_wrap(~varlab, scales = "free_x", ncol = 4) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  ylab("Log odds") +
  scale_y_continuous(breaks = log_odds_breaks,
                     limits = c(-log_odds_limit, log_odds_limit)) +
  theme(axis.title.x = element_blank(), 
        strip.text = element_text(size = 7))

# Discrete plot
log_odds_limit <- max(ceiling(c(abs(p_log_odds$discrete$data$lower), 
                                abs(p_log_odds$discrete$data$upper))))
log_odds_breaks <- seq(-log_odds_limit, log_odds_limit, 1)
p_log_odds_discrete <- p_log_odds$discrete$data %>%
  as_tibble() %>%
  mutate(varlab = get_var_labs(.predictor.)) %>%
  ggplot(aes(x = yhat, y = .xx.)) +
  facet_wrap(~varlab, scales = "free_y", ncol = 4) +
  geom_point(size = .9) +
  geom_errorbarh(aes(xmin = lower , xmax = upper, height = 0)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey") +
  xlab("Log odds") +
  scale_x_continuous(breaks = log_odds_breaks,
                     limits = c(-log_odds_limit, log_odds_limit)) +
  theme(axis.title.y = element_blank(),
        strip.text = element_text(size = 7))

# Combine plots
grid.arrange(p_log_odds_discrete, p_log_odds_continuous,
             heights = c(4, 6))
```

## Predicted probabilities 
The predicted log odds plot is a nice way to summarize non-linear effects, but it's not the ultimate quantity of interest. We really care about predicted probabilities. But to compute a predicted probability we need to set all predictor variables in the model to certain values. Rather that choosing specific values (i.e., creating a representative patient), we will make predictions over a representative sample and average predictions across the sample. 

Note that these plots show the impact of changes in predictor variables *adjusted* for all other variables in the model. The impact of a change in age from 55 to 60 on the probability of mortality is, for instance, estimated after conditioning on the values of the laboratory results, vital signs, comorbidities, other demographics, and calendar time. To assess predicted probabilities without adjustment refer to the univariate fits in the [transformation of continuous variables section](#variable-transformations).

```{r}
# Make newdata
## Start with a random sample of patients
n_samples <- 1000
train_sample <- mi_list[[1]] %>% 
  filter(.imp > 0) %>%
  sample_n(size = n_samples)
```

We will write a general function to predict mortality as a function of (i) our fitted model, (ii) the representative sample, and (iii) the variables that we are varying.

```{r}
expand_newdata <- function(data, vars_to_vary){
  varnames_to_vary <- names(vars_to_vary)
  expanded_vars_to_vary <- expand.grid(vars_to_vary)
  data %>% 
    select(-all_of(varnames_to_vary)) %>%
    crossing(expanded_vars_to_vary)
}

predict_mortality <- function(fit, newdata, vars_to_vary){
  expanded_newdata <- expand_newdata(newdata, vars_to_vary)
  fit_probs <- predict(fit, newdata = data.frame(expanded_newdata), 
                       type = "fitted", se.fit = FALSE)
  
  # Average predictions for variables to vary
  expanded_newdata %>%
    mutate(prob = fit_probs) %>%
    group_by(across(all_of(names(vars_to_vary)))) %>%
    summarise(prob = mean(prob))
}

predict_mortality_boot <- function(fit, newdata, vars_to_vary, B = 100){
  n_obs <- nrow(newdata)
  boot_probs <- vector(mode = "list", length = B)
  for (b in 1:B){
    indices <- sample(x = 1:n_obs, size = n_obs, replace = TRUE) 
    newdata_boot <- newdata[indices, ]
    boot_probs[[b]] <- predict_mortality(fit, newdata_boot, vars_to_vary)
    boot_probs[[b]][, "b"] <- b 
  }
  return(boot_probs %>% bind_rows())
}
```

### Varying age
```{r}
ages_to_vary  <- seq(min(train_data$age),  max(train_data$age), 1)

probs_age <- predict_mortality(lrm_fit_all, newdata = train_sample, 
                               vars_to_vary = list(age = ages_to_vary)) %>%
  rename(Age = age, `Mortality probability` = prob)
```

```{r}
# Table 
my_datatable(probs_age, filename = "mortprob_by_age") %>%
  formatRound("Mortality probability", 4)
```

```{r}
ggplot(probs_age, aes(x = `Age`, y = `Mortality probability`)) +
  geom_line() 
```

### Varying calendar time {#pred-probs-age-time}
```{r}
min_index_date <- min(train_data$index_date)
calendar_times_to_vary <- c(as.Date("2020-03-01"), 
                            as.Date("2020-04-01"), 
                            as.Date("2020-05-01")) - min_index_date 
calendar_times_to_vary <- as.numeric(calendar_times_to_vary)

probs_calendar_time <- predict_mortality(
  lrm_fit_all, newdata = train_sample, 
  vars_to_vary = list(calendar_time = calendar_times_to_vary)
) %>%
  mutate(Date = min_index_date + calendar_time) %>%
  rename(`Calendar time` = calendar_time, `Mortality probability` = prob) %>%
  relocate(Date)
```

```{r}
kable(probs_calendar_time) %>% kable_styling()
```

### Varying age and calendar time
We will start by predicting point estimates only.

```{r}
# Predict point estimates
probs_age_calendar <- predict_mortality(
  lrm_fit_all, newdata = train_sample, 
  vars_to_vary = list(age = ages_to_vary,
                      calendar_time = calendar_times_to_vary))

# Summarize in table
probs_age_calendar %>%
  arrange(calendar_time, age) %>%
  mutate(Date = min_index_date + calendar_time) %>%
  select(-calendar_time) %>%
  relocate(Date) %>%
  rename(`Age` = age,
         `Mortality probability` = prob) %>%
  my_datatable(filename = "mortprob_by_age_time") %>%
  formatRound("Mortality probability", 4)
```

We we will also compute 95% confidence intervals by bootstrapping.

```{r, message = FALSE, cache = TRUE}
bootprobs_age_calendar <- predict_mortality_boot(
  lrm_fit_all, newdata = train_sample, 
  vars_to_vary = list(age = ages_to_vary,
                      calendar_time = calendar_times_to_vary),
  B = n_boot_probs) 
```

Let's plot the results.

```{r predProbs, fig.height = 5, fig.width = 6}
bootprobs_age_calendar %>%
  # Summarize bootstrap results
  group_by(age, calendar_time) %>%
  summarise(
    prob_mean = mean(prob),
    prob_lower = quantile(prob, .025),
    prob_upper = quantile(prob, .975)
  ) %>%
  mutate(date = factor(min_index_date + calendar_time)) %>%

  # Plot
  ggplot(aes(x = age, y = prob_mean)) +
    geom_line(aes(color = date)) +
    geom_ribbon(aes(ymin = prob_lower, ymax = prob_upper, fill = date),
                alpha = 0.2) +
    xlab("Age") +
    ylab("Mortality probability") +
    scale_color_discrete("") +
    scale_fill_discrete("") +
    theme(legend.position = "bottom")
```

# Internal model validation
## Optimism-adjusted model performance
We will start by using bootstrapping to estimate model performance and check for whether our in-sample fits are too optimistic. Specifically, we will use the following algorithm implemented in the `rms` package:

1. Calculate performance from the model fit on the original training sample, denoted as $\theta_{orig}$.
2. For $b = 1,\ldots,B$:
    a. Bootstrap (with replacement) from the original training sample.
    b. Fit the model to the bootstrapped data and estimate model performance, denoted as $\theta_{train}$.
    c. Use the bootstrap fit to measure model performance on the original training sample, denoted as $\theta_{test}$.
3. Calculate "optimism" as $O = B^{-1} \sum_{b = 1}^B \theta_{b, train} - \theta_{b, test}$.
4. Calculate optimism-adjusted performance as $\theta = \theta_{orig} - O$.

A shrinkage factor can also be estimated within each bootstrap sample to gauge the extent of overfitting. This is done by fitting $g(Y) = \gamma_0 + \gamma_1 X\hat{\beta}$ where $X$ and $Y$ are the predictors and outcome, respectively, in the test sample (i.e., in step 2c) and $\hat{\beta}$ is estimated in the training sample (i.e., step 2b). If there is no overfitting, then $\gamma_0 = 0$ and $\gamma_1 = 1$; conversely, if there is overfitting, then $\gamma_1 < 1$ and $\gamma_0 \neq 1$ to compensate.  


```{r, cache = TRUE}
lrm_val_age <- validate(lrm_fit_age, B = n_boot_val)
lrm_val_c <- validate(lrm_fit_c, B = n_boot_val) 
lrm_val_d <- validate(lrm_fit_d, B = n_boot_val)
lrm_val_dc <- validate(lrm_fit_dc, B = n_boot_val)
lrm_val_all <- validate(lrm_fit_all, B = n_boot_val) 
lrm_val_train <- list(lrm_val_age, lrm_val_c, lrm_val_d,
                      lrm_val_dc, lrm_val_all)
```

```{r}
bind_cindex <- function(object){
  n_rows <- nrow(object)
  c_index <- (object["Dxy", 1:3] + 1)/2
  c_index[4] <- c_index[2] - c_index[3]
  c_index[5] <- c_index[1] - c_index[4]
  c_index[6] <- object[1, 6]
  
  return(rbind(object, c_index))
}

make_validation_tbl <- function(object){
  object %>% 
    bind_cindex() %>%
    set_colnames(c("(1) Original", "(2) Bootstrap training", 
                   "(3) Bootstrap test", "Optimism: (2) - (3)", 
                   "Original (corrected): (1) - (4)", "N")) %>%
    kable() %>%
    kable_styling()
}

make_validation_tbl(lrm_val_age)
make_validation_tbl(lrm_val_c) 
make_validation_tbl(lrm_val_all)
```

## Calibration curves {#calibration-train}
We will first use the bootstrap so that we can generate bias adjusted predictions. 

```{r calCurve, cache = TRUE}
# Calibrate
lrm_cal_age <- calibrate(lrm_fit_age, B = n_boot_val)
lrm_cal_c <- calibrate(lrm_fit_c, B = n_boot_val)
lrm_cal_d <- calibrate(lrm_fit_d, B = n_boot_val)
lrm_cal_dc <- calibrate(lrm_fit_dc, B = n_boot_val)
lrm_cal_all <- calibrate(lrm_fit_all, B = n_boot_val)
lrm_cal_list <- list(lrm_cal_age, lrm_cal_c, lrm_cal_d, lrm_cal_dc, lrm_cal_all)
names(lrm_cal_list) <- lrm_names
```

Calibration plots can then be created.

```{r, fig.width = 8, fig.height = 6}
plot_calibration <- function(object){
  # Make tibble
  cal_df <- map2(object, names(object), function(x, y){
    x[, ] %>%
      as_tibble() %>%
      mutate(model = y)
  }) %>% 
    bind_rows() %>%
    mutate(model = factor(model, levels = lrm_names))
  
  
  # Plot
  breaks <- seq(0, 1, .2)

  ggplot() + 
    geom_line(data = cal_df, mapping = aes(x = predy, y = calibrated.orig, 
                                           color = "Apparent")) + 
    geom_line(data = cal_df, mapping = aes(x = predy, y = calibrated.corrected,
                                           color = "Bias-corrected")) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey") +
    facet_wrap(~model) +
    scale_x_continuous(breaks = breaks, limits = c(0, 1)) +
    scale_y_continuous(breaks = breaks, limits = c(0, 1)) +
    xlab("Predicted probability") +
    ylab("Actual probability") +
    scale_colour_manual(name = "",
                        values = c("Apparent" = "black", 
                                   "Bias-corrected" = "red")) +
    theme(legend.position = "bottom") 
}

plot_calibration(lrm_cal_list)
```

Calibration at the tails of the predictive distribution might be based on fewer patients, so it can be useful to plot the distribution of predicted probabilities. We start with histograms.

```{r, fig.width = 8, fig.height = 6}
predprobs_df <- map2(lrm_cal_list, names(lrm_cal_list), function (x, model_name){ 
  x_df <- tibble(model =model_name, predicted = attr(x, "predicted"))
  }) %>%
   bind_rows() %>%
  mutate(model = factor(model, levels = names(lrm_cal_list)))

plot_predprobs_hist <- function(data){
  ggplot(data, aes(x = predicted)) + 
    facet_wrap(~model, scales = "free_y") +
    geom_histogram(fill = "black", bins = 200) +
    scale_x_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
    scale_y_continuous(breaks = function (x) floor(seq(0, .9 * max(x), 
                                                       length.out = 7))) +
    xlab("Predicted Probability") +
    ylab("Count") 
}

plot_predprobs_hist(predprobs_df)
```

The cumulative density function (CDF) is also informative since it provides the proportion of patients with predicted probabilities above and below given thresholds. For example, we can see that in the full model only a proportion `r formatC(1 - ecdf(predprobs_df[predprobs_df$model == "All variables", ]$predicted)(.5), format = "f", digits = 2)` have predicted probabilities above 0.5.

```{r, fig.width = 8, fig.height = 6}
plot_predprobs_cdf <- function(data){
  ggplot(data, aes(x = predicted, col = model)) + 
    stat_ecdf() +
    scale_x_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
    scale_y_continuous(breaks = seq(0, 1, by = 0.1)) +
    xlab("Predicted Probability") +
    ylab("CDF") +
    scale_color_discrete(name = "") +
    theme(legend.position = "bottom")
}

plot_predprobs_cdf(predprobs_df)
```

# Model validation on test set
The specification of the model has been finalized so we are ready to assess it on the test set. 

## Preprocess test data
To make predictions on the training set, we must preprocess the data in the same way that we preprocessed the training data. 

```{r, message = TRUE}
test_data <- readRDS("test_data.rds")  %>%
  filter_ie()

# Clean data
test_data <- clean_data(test_data)

# Truncate labs
test_data <- add_truncated_lab_vars(test_data, v = lab_vars$var)
```

Multiple imputation will be performed on the combined train and test set.

```{r, cache = TRUE, results = "hide"}
# Missing data imputation
## rbind training and test sets
train_data$set = "train"
test_data$set = "test"
train_test_data <- bind_rows(train_data, test_data)

## Multiple imputation via MICE
mice_train_test <- train_test_data %>%
  select(one_of(mice_vars)) %>%
  mutate_if(is.character, as.factor) %>%
  mice(m = n_imputations, maxit = 5)

## Add death and subset to test set
mi_df_test <- complete(mice_train_test, action = "long", include = FALSE) %>%
  as_tibble() %>%
  mutate(died = rep(train_test_data$died, mice_train_test$m),
         set = rep(train_test_data$set, mice_train_test$m)) %>%
  filter(set == "test")

## Create race/ethnicity variable
mi_df_test <-  add_race_ethnicity(mi_df_test)
```

Before making predictions, it is helpful to compare the training and test sets.

```{r}
tbl1_train_test <- train_test_data %>%
  select(one_of("died", "set", tbl1_varnames)) %>%
  rename_with(get_var_labs, .cols = all_of(tbl1_varnames)) %>%
  rename(Died = died) %>%
  mutate(set = ifelse(set == "train", "Train set", "Test set")) %>%
  CreateTableOne(vars = c("Died", get_var_labs(tbl1_varnames)), 
                 factorVars = c("Died", get_var_labs(tbl1_cat_varnames)), 
                 strata = "set",  addOverall = TRUE, 
                 data = .)

print(tbl1_train_test, nonnormal = get_var_labs(tbl1_non_normal_varnames),  
      cramVars = c("Sex"),
      contDigits = 3, missing = TRUE, printToggle = FALSE) %>%
  set_colnames(c("Overall", "Test set", "Train set",
                "p", "Test", "Missing")) %>%
  kable() %>%
  kable_styling()
```

## Predict
Our main predictions are based on the unpenalized logistic regression.
```{r}
lrm_fits <- list(age = lrm_fit_age, 
                 c = lrm_fit_c,
                 d = lrm_fit_d,
                 dc = lrm_fit_dc,
                 all= lrm_fit_all)
lrm_prob_names <- paste0("lrm_probs_", names(lrm_fits))
for (i in 1:length(lrm_fits)){
  mi_df_test[[lrm_prob_names[i]]] <- predict(lrm_fits[[i]], 
                                             newdata = as.data.frame(mi_df_test), 
                                             type = "fitted", se.fit = FALSE)
}
```

## Evaluation metrics {#evaluation-metrics-test}
Let's evaluate the models using the metrics returned by `rms::val.prob()`.

```{r}
lrm_val_test <- vector(mode = "list", length = length(lrm_fits))
names(lrm_val_test) <- lrm_names
for (i in 1:length(lrm_val_test)){
  lrm_val_test[[i]] <- val.prob(p = mi_df_test[[lrm_prob_names[i]]],
                                y = mi_df_test$died,
                                pl = FALSE)
}
```

```{r}
summarize_val_probs <- function(object){
  map_df(object, function (x) {
  as_tibble(matrix(x, nrow = 1)) %>%
    set_colnames(names(x))
}, .id = "Model") %>%
  kable(digits = 4) %>%
  kable_styling() %>%
  scroll_box(width = "100%")
}
summarize_val_probs(lrm_val_test)
```


We will focus on the Brier score and C-Index and assess performance on both the training and test sets.

```{r performanceSummary}
summarize_performance <- function(val_train, val_test){
  # Get metrics
  train_metrics <- map_df(val_train, function (x) {
    x[c("Dxy", "B"), "index.orig"]
    }) %>%
    mutate(Dxy = (Dxy + 1)/2) %>%
    rename(c_index = Dxy)
  
  test_metrics <- map_df(val_test, function(x) x[c("C (ROC)", "Brier")])
  
  # Make table
  bind_cols(
    tibble(Model = names(val_test)),
    train_metrics,
    test_metrics
  ) %>%
    kable(col.names = c("Model", "C-Index", "Brier", "C-Index", "Brier"),
          digits = 4) %>%
    kable_styling() %>%
    add_header_above(c(" ", "Train" = 2, "Test" = 2))
}

summarize_performance(val_train = lrm_val_train, val_test = lrm_val_test)
```

## Calibration curves {#calibration-test}
Like we did with the training set, we will plot calibration curves. 

```{r}
make_cal_test_data <- function(data, p , model_names){
  data[, c("died", ".imp", p)] %>%
    pivot_longer(cols = c(p), names_to = "model",
               values_to = "predicted") %>%
    rename(actual = died) %>%
    mutate(model = model_names[match(model, p)],
          model = factor(model, levels = model_names))
}

plot_calibration_test <- function(cal_data){
  ggplot(cal_data, aes(x = predicted, y = actual)) +
    facet_wrap(~model) +
    geom_smooth(se = FALSE, method = "loess", formula = y ~ x, color = "black",
                size = 1) +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey") +
    scale_x_continuous(breaks = seq(0, 1, .2), limits = c(0, 1)) +
    scale_y_continuous(breaks = seq(0, 1, .2), limits = c(0, 1)) +
    xlab("Predicted probability") +
    ylab("Actual probability") +
    theme(legend.position = "bottom")
}

cal_test_data <- make_cal_test_data(mi_df_test, p = lrm_prob_names,
                                    model_names = lrm_names)
plot_calibration_test(cal_test_data)
```

It is again useful to visualize the distribution of predicted probabilities since calibration at the tails might be based on a smaller number of patients. 

```{r, fig.width = 8, fig.height = 6}
plot_predprobs_hist(cal_test_data)
```

```{r, fig.width = 8, fig.height = 6}
plot_predprobs_cdf(cal_test_data)
```

## Penalized models
We will run sensitivity analyses on the full model to see if penalization can improve calibration and/or discrimination. The three models that we will consider are (i) logistic regression with a ridge penalty, (ii) logistic regression with a lasso penalty, and (iii) the standard unpenalized logistic regression (i.e., from the results presented above).

The penalized logistic regression models can be fit using `glmnet`. 

```{r, cache = TRUE}
x_train <- mi_list %>% map(function(data) 
  make_x(data, model_rhs)
)

# Cross validation
lasso_cvfits <- ridge_cvfits <-  vector(mode = "list", length = length(x_train))
for (i in 1:length(lasso_cvfits)){
  ridge_cvfits[[i]] <- cv.glmnet(x = x_train[[i]], y = y[[i]], 
                                 family = "binomial", alpha = 0)
  lasso_cvfits[[i]] <- cv.glmnet(x = x_train[[i]], y = y[[i]], 
                                 family = "binomial", alpha = 1)
}
```

Now let's make predictions for the penalized models. The prediction for a given patient is the average prediction across the imputed datasets. 

```{r}
predict_glmnet_mi <- function(fits, newx){
  n_fits <- length(fits)
  pred <- matrix(NA, nrow = nrow(newx), ncol = n_fits)
  for (j in 1:n_fits){
    pred[, j] <- predict(fits[[i]], newx = x_test, 
                         s = "lambda.1se", type = "response")
  }
  return(apply(pred, 1, mean)) 
}

x_test <- make_x(mi_df_test, model_rhs)
mi_df_test$ridge_probs_all <- predict_glmnet_mi(ridge_cvfits, x_test)
mi_df_test$lasso_probs_all <- predict_glmnet_mi(lasso_cvfits, x_test)
```

With predictions in hand, we can evaluate the model.

```{r}
penalized_val_test <- vector(mode = "list", length = 2)
names(penalized_val_test) <- c("Lasso", "Ridge")
penalized_prob_names <- paste0(c("lasso", "ridge"), "_probs_all")
for (i in 1:length(penalized_val_test)){
  penalized_val_test[[i]] <- val.prob(p = mi_df_test[[penalized_prob_names[i]]],
                                      y = mi_df_test$died,
                                      pl = FALSE)
}  
```

We will first assess various evaluation metrics with an emphasis on the Brier score and C-Index.

```{r}
summarize_val_probs(penalized_val_test)
```

Finally, we will compare calibration curves for each of the three models.

```{r, fig.height = 3, fig.width = 8}
make_cal_test_data(mi_df_test,
                   p = c(penalized_prob_names, "lrm_probs_all"),
                   model_names = c(names(penalized_val_test), "No penalty")) %>%
  plot_calibration_test()
```
  
# Session information
```{r}
sessionInfo()
```